class Solution {
    // Helper function for depth-first search (DFS)
    private void dfs(List<List<Integer>> gr, boolean[] visited, int[] c, int i) {
        visited[i] = true;
        c[0]++;
        for (int j : gr.get(i)) {
            if (!visited[j]) {
                dfs(gr, visited, c, j);
            }
        }
    }

    public int maximumDetonation(int[][] bombs) {
        int n = bombs.length;

        // Create adjacency list representation of the graph
        List<List<Integer>> gr = new ArrayList<>(n);
        for (int i = 0; i < n; i++) {
            gr.add(new ArrayList<>());
            for (int j = 0; j < n; j++) {
                if (i != j) {
                    // Calculate the squared distance between bombs i and j
                    long x1 = bombs[i][0];
                    long y1 = bombs[i][1];
                    long r1 = bombs[i][2];
                    long x = bombs[j][0];
                    long y = bombs[j][1];
                    long distanceSq = (x - x1) * (x - x1) + (y - y1) * (y - y1);

                    // If j is within the blast radius of i, add j to the adjacency list of i
                    if (distanceSq <= r1 * r1) {
                        gr.get(i).add(j);
                    }
                }
            }
        }

        int ans = Integer.MIN_VALUE;
        for (int i = 0; i < n; i++) {
            int[] c = new int[1];
            boolean[] visited = new boolean[n];

            // Perform depth-first search from bomb i
            dfs(gr, visited, c, i);

            // Update the maximum number of detonations
            ans = Math.max(ans, c[0]);
        }

        return ans;
    }
}
